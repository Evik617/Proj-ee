import pygameimport os# Инициализация pygamepygame.init()# КонстантыWIDTH = 800HEIGHT = 600FPS = 60WHITE = (255, 255, 255)BLACK = (0, 0, 0)BROWN = (139, 69, 19)LIGHT_BROWN = (170, 100, 50)VERY_LIGHT_BROWN = (222, 184, 135)DARK_BROWN = (101, 67, 33)DARK_BLUE = (0, 0, 139)DARK_PINK = (139, 0, 139)LIGHT_BLUE = (173, 216, 230)LIGHT_PINK = (255, 182, 193)DARK_GREEN = (0, 100, 0)# Загрузка ресурсов (иконок, шрифтов)def load_image(path, size=None):    img = pygame.image.load(path).convert_alpha()    if size:        img = pygame.transform.scale(img, size)    return img# Загружает шрифт из файлаdef load_font(path, size):    return pygame.font.Font(path, size)# Класс для создания кнопокclass Button(pygame.sprite.Sprite):    def __init__(self, text, x, y, width, height, action=None, is_selected=False,                 color=BROWN, enabled=True):        super().__init__()        self.font = load_font("assets/font/your_font.ttf", 20)        self.text = text        self.width = width        self.height = height        self.normal_color = color        self.hover_color = LIGHT_BROWN        self.selected_color = color        self.light_color = None        if color == DARK_BLUE:            self.light_color = LIGHT_BLUE        elif color == DARK_PINK:            self.light_color = LIGHT_PINK        if self.text == "Next" or self.text == "Play" or self.text == "Next level":            self.hover_color = VERY_LIGHT_BROWN        if self.text == "Who?":            self.hover_color = VERY_LIGHT_BROWN        self.image = pygame.Surface((width, height))        self.is_selected = is_selected        self.enabled = enabled        if self.is_selected:            self.image.fill(self.selected_color)        else:            self.image.fill(self.normal_color)        self.rect = self.image.get_rect(center=(x, y))        self.text_surface = self.font.render(text, True, WHITE)        self.text_rect = self.text_surface.get_rect(center=self.rect.center)        self.action = action        self.is_pressed = False        self.press_timer = 0        self.clicked = False    # Отрисовывает кнопку на заданной поверхности    def draw(self, surface):        surface.blit(self.image, self.rect)        self.text_rect = self.text_surface.get_rect(center=self.rect.center)        surface.blit(self.text_surface, self.text_rect)        if self.is_selected:            pygame.draw.rect(surface, BLACK, self.rect, 3)    # Активирует эффект нажатия кнопки    def press(self):        if self.enabled and not self.is_pressed:            self.is_pressed = True            self.image.fill(self.hover_color)            self.press_timer = pygame.time.get_ticks()    # Сбрасывает эффект нажатия кнопки    def unpress(self):        self.is_pressed = False        if self.is_selected:            self.image.fill(self.selected_color)        else:            self.image.fill(self.normal_color)    # Выделяет кнопку    def select(self):        self.is_selected = True        self.image.fill(self.selected_color)    # Снимает выделение с кнопки    def unselect(self):        self.is_selected = False        self.image.fill(self.normal_color)    # Обрабатывает события мыши для кнопки    def handle_event(self, event):        if self.enabled:            if event.type == pygame.MOUSEBUTTONDOWN:                if event.button == 1 and self.rect.collidepoint(                        event.pos) and not self.is_pressed and not self.clicked:                    self.press()                    self.clicked = True                    return self.action            if event.type == pygame.MOUSEBUTTONUP:                self.clicked = False        return None    # Обновляет состояние кнопки в зависимости от движения мыши    def update(self, event=None):        if event and event.type == pygame.MOUSEMOTION:            if self.rect.collidepoint(event.pos):                if self.enabled:                    if self.text == "Boy" and not self.is_selected:                        self.image.fill(LIGHT_BLUE)                    elif self.text == "Girl" and not self.is_selected:                        self.image.fill(LIGHT_PINK)                    elif self.light_color and not self.is_selected:                        self.image.fill(self.light_color)                    elif not self.is_selected:                        self.image.fill(self.hover_color)            else:                if not self.is_selected:                    self.image.fill(self.normal_color)        if self.is_pressed:            if pygame.time.get_ticks() - self.press_timer > 100:                self.unpress()# Класс игрокаclass Player(pygame.sprite.Sprite):    def __init__(self, char_type, start_x=100, start_y=HEIGHT - 100, animation_speed=150):        super().__init__()        self.char_type = char_type        self.images = []        path = f"../assets/characters/{self.char_type}/"        for i in range(1, 7):            img_path = os.path.join(path, f"run_{i}.png")            if os.path.exists(img_path):                self.images.append(load_image(img_path, (80, 120)))            else:                break        self.current_image = 0        self.image = self.images[self.current_image]        self.rect = self.image.get_rect(midbottom=(start_x, start_y))        self.speed_x = 5        self.is_jumping = False        self.jump_speed = -12        self.gravity = 0.8        self.y_velocity = 0        self.animation_speed = animation_speed        self.animation_timer = 0        self.jumps_remaining = 2    # Обновляет положение и анимацию персонажа    def update(self):        if pygame.time.get_ticks() - self.animation_timer > self.animation_speed:            self.current_image = (self.current_image + 1) % len(self.images)            self.image = self.images[self.current_image]            self.animation_timer = pygame.time.get_ticks()        # Движение по горизонтали        keys = pygame.key.get_pressed()        if keys[pygame.K_RIGHT]:            self.rect.x += self.speed_x        if keys[pygame.K_LEFT]:            self.rect.x -= self.speed_x        # Ограничение движения по краям экрана        if self.rect.right > WIDTH:            self.rect.right = WIDTH        if self.rect.left < 0:            self.rect.left = 0        # Прыжок        if self.is_jumping:            self.y_velocity += self.gravity            self.rect.y += self.y_velocity            if self.rect.bottom >= HEIGHT - 10:                self.rect.bottom = HEIGHT - 10                self.is_jumping = False                self.y_velocity = 0                self.jumps_remaining = 2    # Выполняет прыжок, если возможно    def jump(self):        if self.jumps_remaining > 0:            self.is_jumping = True            self.y_velocity = self.jump_speed            self.jumps_remaining -= 1# Класс бонусаclass Bonus(pygame.sprite.Sprite):    def __init__(self, x, y, image_path):        super().__init__()        self.image = load_image(image_path)        if image_path == "assets/bonuses/ball.png":            size = (52, 51)        elif image_path == "assets/bonuses/flask.png":            size = (52, 55)        elif image_path == "assets/bonuses/book.png":            size = (52, 49)        else:            size = (30, 30)        self.image = pygame.transform.scale(self.image, size)        self.rect = self.image.get_rect(center=(x, y))# Класс уровняclass Level:    def __init__(self, level_num):        self.level_num = level_num        background_path = os.path.join("assets", "levels", f"level_{level_num}", "background.png")        self.background = load_image(background_path, (WIDTH, HEIGHT))        self.bonuses = pygame.sprite.Group()        self.start_x = 100        self.start_y = HEIGHT - 100        self.initial_bonus_positions = self.load_bonuses_positions(level_num)        if self.initial_bonus_positions:            for x, y, image_path in self.initial_bonus_positions:                self.bonuses.add(Bonus(x, y, image_path))        self.level_start_delay = 3        self.level_time = 5    # Загружает позиции бонусов для данного уровня    def load_bonuses_positions(self, level_num):        if level_num == 1:            return [(150, HEIGHT - 400, "assets/bonuses/ball.png"),                    (250, HEIGHT - 151, "assets/bonuses/ball.png"),                    (350, HEIGHT - 205, "assets/bonuses/ball.png"),                    (450, HEIGHT - 203, "assets/bonuses/ball.png"),                    (550, HEIGHT - 152, "assets/bonuses/ball.png"),                    (600, HEIGHT - 241, "assets/bonuses/ball.png"),                    (700, HEIGHT - 210, "assets/bonuses/ball.png"),                    (750, HEIGHT - 223, "assets/bonuses/ball.png"),                    (650, HEIGHT - 310, "assets/bonuses/ball.png"),                    (200, HEIGHT - 22, "assets/bonuses/ball.png")]        elif level_num == 2:            return [(100, HEIGHT - 302, "assets/bonuses/flask.png"),                    (200, HEIGHT - 27, "assets/bonuses/flask.png"),                    (300, HEIGHT - 213, "assets/bonuses/flask.png"),                    (400, HEIGHT - 176, "assets/bonuses/flask.png"),                    (500, HEIGHT - 13, "assets/bonuses/flask.png"),                    (600, HEIGHT - 136, "assets/bonuses/flask.png"),                    (700, HEIGHT - 312, "assets/bonuses/flask.png"),                    (150, HEIGHT - 102, "assets/bonuses/flask.png"),                    (350, HEIGHT - 83, "assets/bonuses/flask.png"),                    (550, HEIGHT - 203, "assets/bonuses/flask.png")]        elif level_num == 3:            return [(150, HEIGHT - 400, "assets/bonuses/book.png"),                    (200, HEIGHT - 142, "assets/bonuses/book.png"),                    (300, HEIGHT - 153, "assets/bonuses/book.png"),                    (400, HEIGHT - 151, "assets/bonuses/book.png"),                    (500, HEIGHT - 223, "assets/bonuses/book.png"),                    (600, HEIGHT - 102, "assets/bonuses/book.png"),                    (100, HEIGHT - 52, "assets/bonuses/book.png"),                    (300, HEIGHT - 312, "assets/bonuses/book.png"),                    (500, HEIGHT - 51, "assets/bonuses/book.png"),                    (700, HEIGHT - 53, "assets/bonuses/book.png")]        else:            return None    # Отрисовывает фон уровня на заданной поверхности    def draw_background(self, surface):        surface.blit(self.background, (0, 0))# Класс для управления сценами игрыclass SceneManager:    def __init__(self, db_path=""):        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))        pygame.display.set_caption("School Run")        self.running = True        self.current_scene = "start_screen"        self.current_level_screen = "start_menu"        self.clock = pygame.time.Clock()        self.font = load_font("assets/font/your_font.ttf", 24)        self.selected_character = None        self.selected_level = None        self.score = 0        self.levels = [Level(1), Level(2), Level(3)]        self.player = None        self.start_time = 0        self.game_time = 0        self.start_background = load_image(            os.path.join("assets", "start_screen", "background.png"),            (WIDTH, HEIGHT))        self.menu_background = load_image(            os.path.join("assets", "character_select", "background.png"),            (WIDTH, HEIGHT))        self.previous_selected_character = None        self.first_screen_image = load_image(            os.path.join("assets", "other", "first_screen.png"), (WIDTH, HEIGHT))        self.first_screen_button = None        self.who_screen_image = None  # Добавляем переменную для картинки        self.who_screen_image = load_image(os.path.join("assets", "other", "who_screen.png"),                                           (WIDTH, HEIGHT))  # Загружаем картинку        self.level_complete_image = None  # переменная для картинок перед уровнями        self.level_complete_images = [            load_image(os.path.join("assets", "other", "level_1_start.png"), (WIDTH, HEIGHT)),            load_image(os.path.join("assets", "other", "level_2_start.png"), (WIDTH, HEIGHT)),            load_image(os.path.join("assets", "other", "level_3_start.png"), (WIDTH, HEIGHT)),        ]        self.final_screen_image = load_image(os.path.join("assets", "other", "final_screen.png"),                                             (WIDTH, HEIGHT))  # финальная фотка        self.boy_button = Button("Boy", WIDTH // 2 - 150, HEIGHT - 100, 150, 40,                                 action="boy", color=DARK_BLUE)        self.girl_button = Button("Girl", WIDTH // 2 + 150, HEIGHT - 100, 150, 40,                                  action="girl", color=DARK_PINK)        self.character_buttons = [self.boy_button, self.girl_button]        self.level_buttons = []        for i in range(3):            level_button = Button(f"Level {i + 1}", WIDTH // 2,                                  HEIGHT // 2 - 50 + i * 60, 200, 40,                                  action=f"level_{i + 1}")            self.level_buttons.append(level_button)        self.end_button = Button("Who?", WIDTH // 2, HEIGHT // 2 - 100, 200, 60,                                 action="end_screen_transition")  # Создаём кнопку "Who?"        self.end_game_button = None        self.restart_button = Button("Restart", WIDTH // 2, HEIGHT // 2 + 100,                                     150, 40, action="start_menu")        self.reset_button = Button("Reset", 50, 50, 100, 30, action="reset")        self.play_button = Button("Play", WIDTH // 2, HEIGHT // 2, 150, 50,                                  action="first_screen", color=LIGHT_BROWN)        self.quit_button = None        self.restart_end_button = None        self.next_end_button = Button("Next", WIDTH // 2, HEIGHT - 70, 150, 40, action="final_screen",                                      color=BROWN)  # Кнопка Next после who        self.end_screen_background = load_image(os.path.join("assets", "other", "end_screen.png"), (WIDTH, HEIGHT))        self.next_level_button = Button("Next", WIDTH // 2, HEIGHT - 70, 150, 40, action="game",                                        color=BROWN)  # Кнопка Next перед уровнем        self.completed_levels = set()        self.level_start_time = 0        self.end_game_button = None        self.level_before_start = True  # флаг показа экрана перед уровнем        self.final_restart_button = Button("Restart", WIDTH // 2 - 100, HEIGHT // 2 + 150, 150, 40,                                           action="start_menu")  # кнопка рестарта в финальном экране        self.final_quit_button = Button("Exit", WIDTH // 2 + 100, HEIGHT // 2 + 150, 150, 40,                                        action="quit")  # кнопка quit в финальном экране        self.end_screen_transition = False        self.instruction_start_time = 0  # Добавляем переменную для отсчета времени        self.next_level_button_clicked = False  # Добавляем флаг для кнопки next level        self.character_changed = False    # Запускает основной цикл игры    def run(self):        while self.running:            self.clock.tick(FPS)            for event in pygame.event.get():                if event.type == pygame.QUIT:                    self.running = False                if event.type == pygame.KEYDOWN:                    if event.key == pygame.K_SPACE and self.current_scene == "game" and self.player:                        self.player.jump()                action = None                if self.current_scene == "start_screen":                    action = self.handle_start_screen_events(event)                elif self.current_scene == "first_screen":                    next_button = self.draw_first_screen()                    action = self.handle_first_screen_events(event, next_button)                    next_button.update(event)                elif self.current_scene == "start_menu":                    action = self.handle_start_menu_events(event)                elif self.current_scene == "game":                    action = self.handle_game_events(event)                elif self.current_scene == "end_menu_select":                    action = self.handle_end_menu_select_events(event)                elif self.current_scene == "end_screen":                    action = self.handle_end_screen_events(event)                elif self.current_scene == "end_screen_transition":                    action = self.handle_end_screen_transition_events(event)                elif self.current_scene == "level_complete":                    action = self.handle_level_complete_events(event)                elif self.current_scene == "level_instruction_screen":                    # action = self.handle_level_instruction_events(event) # <--- Убрали event                    action = self.handle_level_instruction_events() # <--- вызываем метод без event                elif self.current_scene == "final_screen":                    action = self.handle_final_screen_events(event)                for button in self.level_buttons:                    button.update(event)                for button in [self.boy_button, self.girl_button,                               self.play_button, self.reset_button, self.next_end_button, self.end_button,                               self.next_level_button, self.final_quit_button, self.final_restart_button]:                    button.update(event)                if self.end_game_button:                    self.end_game_button.update(event)                if self.first_screen_button:                    self.first_screen_button.update(event)                if self.restart_button:                    self.restart_button.update(event)                if action:                    self.current_scene = action            if self.current_scene == "start_screen":                self.draw_start_screen()            elif self.current_scene == "first_screen":                self.draw_first_screen()            elif self.current_scene == "start_menu":                self.draw_start_menu()            elif self.current_scene == "game":                self.draw_game()            elif self.current_scene == "end_menu_select":                self.draw_end_menu_select()            elif self.current_scene == "end_screen":                self.draw_end_screen()            elif self.current_scene == "end_screen_transition":                self.draw_end_screen_transition()            elif self.current_scene == "level_complete":                self.draw_level_complete()            elif self.current_scene == "level_instruction_screen":                self.draw_level_instruction_screen()            elif self.current_scene == "final_screen":                self.draw_final_screen()            # Обновляем кнопки            for button in (                    self.boy_button, self.girl_button, *self.level_buttons, self.next_end_button, self.end_button,                    self.next_level_button, self.final_quit_button, self.final_restart_button):                if button:                    button.update()            if self.end_game_button:                self.end_game_button.update()            if self.first_screen_button:                self.first_screen_button.update()            self.restart_button.update()            self.reset_button.update()            self.play_button.update()            pygame.display.flip()        pygame.quit()    # Обрабатывает события на стартовом экране    def handle_start_screen_events(self, event):        if self.play_button.handle_event(event) == "first_screen":            return "first_screen"        return None    # Обрабатывает события на первом экране (инструкции)    def handle_first_screen_events(self, event, next_button):        if next_button.handle_event(event) == "start_menu":            return "start_menu"        return None    # Обрабатывает события на экране выбора персонажа и уровня    def handle_start_menu_events(self, event):        if self.boy_button.handle_event(event) == "boy":            self.selected_character = "boy"            self.boy_button.select()            self.girl_button.unselect()            self.character_changed = True            self.previous_selected_character = "boy"        elif self.girl_button.handle_event(event) == "girl":            self.selected_character = "girl"            self.girl_button.select()            self.boy_button.unselect()            self.character_changed = True            self.previous_selected_character = "girl"        # Обрабатываем событие выбора уровня        for i, button in enumerate(self.level_buttons):            if button.handle_event(event) == f"level_{i + 1}":                if i <= len(self.completed_levels):                    if not self.selected_character:                        self.selected_character = "boy"                    self.selected_level = i                    self.level_before_start = True                    self.next_level_button_clicked = False                    return "level_complete"        if len(self.completed_levels) >= 3:            return None        if self.reset_button.handle_event(event) == "reset":            self.reset_game()            return "start_screen"        return None    # Обрабатывает события во время игры    def handle_game_events(self, event):        if self.player and self.player.rect.x > WIDTH - 100:            if not self.end_game_button:                if len(self.completed_levels) == 2:                    self.end_game_button = Button("Next level", WIDTH // 2,                                                  HEIGHT // 2 + 100, 150, 40,                                                  action="end_menu_select")                else:                    self.end_game_button = Button("Next level", WIDTH // 2,                                                  HEIGHT // 2 + 100, 150, 40,                                                  action="start_menu")            if self.end_game_button.handle_event(event) and not self.next_level_button_clicked:                self.next_level_button_clicked = True                self.completed_levels.add(self.selected_level)                self.score = 0                self.selected_character = None                self.character_changed = False                for button in self.character_buttons:                    button.unselect()                self.player = None                if len(self.completed_levels) == 3:                    return "end_menu_select"                return "start_menu"        return None    # Обрабатывает события на экране выбора перехода в финальную сцену    def handle_end_menu_select_events(self, event):        if self.end_button.handle_event(event) == "end_screen_transition":            self.end_screen_transition = True            return "end_screen_transition"        return None    # Обрабатывает события на экране завершения уровня    def handle_level_complete_events(self, event):        if self.next_level_button.handle_event(event) == "game":            self.instruction_start_time = pygame.time.get_ticks()            self.level_before_start = False            return "level_instruction_screen"        return None    # Обрабатывает события на экране инструкции перед уровнем    def handle_level_instruction_events(self):        if pygame.time.get_ticks() - self.instruction_start_time > 3000:            return "game"        return None    # Обрабатывает события на финальном экране    def handle_final_screen_events(self, event):        if self.final_quit_button.handle_event(event) == "quit":            self.running = False            return None        if self.final_restart_button.handle_event(event) == "start_menu":            self.reset_game()            return "start_screen"        return None    # Обрабатывает события на экране перехода в финальную сцену    def handle_end_screen_transition_events(self, event):        if self.next_end_button.handle_event(event) == "final_screen":            return "final_screen"        return None    # Отрисовывает стартовый экран    def draw_start_screen(self):        self.screen.blit(self.start_background, (0, 0))        self.play_button.draw(self.screen)    # Отрисовывает первый экран (инструкции)    def draw_first_screen(self):        self.screen.blit(self.first_screen_image, (0, 0))        button_width = 150        button_height = 50        if self.first_screen_button is None:            self.first_screen_button = Button("Next", WIDTH // 2, HEIGHT - 70, button_width, button_height,                                              action="start_menu", color=BROWN)        self.first_screen_button.draw(self.screen)        return self.first_screen_button    # Отрисовывает экран выбора персонажа и уровня    def draw_start_menu(self):        self.screen.blit(self.menu_background, (0, 0))        # Создание полупрозрачного белого фона        text_bg_surface = pygame.Surface((WIDTH, 100), pygame.SRCALPHA)        text_bg_surface.fill((255, 255, 255, 128))        text_bg_rect = text_bg_surface.get_rect(center=(WIDTH // 2, 150))        self.screen.blit(text_bg_surface, text_bg_rect)        # Создание текста        text_font = load_font("assets/font/your_font.ttf", 40)        text = text_font.render("Choose Your Character and Level!", True, BROWN)        text_rect = text.get_rect(center=(WIDTH // 2, 150))        self.screen.blit(text, text_rect)        # Устанавливаем выделение на предыдущего выбранного персонажа, ЕСЛИ персонаж не был изменён        if self.previous_selected_character and not self.character_changed:            if self.previous_selected_character == "boy":                self.boy_button.select()                self.selected_character = "boy"            elif self.previous_selected_character == "girl":                self.girl_button.select()                self.selected_character = "girl"        # Отрисовываем кнопки персонажа по середине внизу        self.boy_button.draw(self.screen)        self.girl_button.draw(self.screen)        if len(self.completed_levels) < 3:            for i, button in enumerate(self.level_buttons):                button.rect.y = HEIGHT // 2 - 50 + i * 60                if i < len(self.completed_levels):                    button.normal_color = DARK_GREEN                    button.enabled = False                    pygame.draw.rect(self.screen, BLACK, button.rect, 3)                elif i == len(self.completed_levels):                    button.normal_color = BROWN                    button.enabled = True                else:                    button.normal_color = DARK_BROWN                    button.enabled = False                    pygame.draw.rect(self.screen, BLACK, button.rect, 3)                button.draw(self.screen)        self.reset_button.draw(self.screen)    # Отрисовывает экран перехода в финальную сцену    def draw_end_menu_select(self):        if self.who_screen_image:  # <--- Отрисовываем картинку если она есть            self.screen.blit(self.who_screen_image, (0, 0))        self.end_button.draw(self.screen)    # Отрисовывает финальный экран    def draw_end_screen(self):        self.screen.blit(self.end_screen_background, (0, 0))  # <-- отрисовка фона    # Отрисовывает экран перехода в финальную сцену    def draw_end_screen_transition(self):        self.screen.blit(self.end_screen_background, (0, 0))  # <-- отрисовка фона        self.next_end_button.rect.y = HEIGHT - 70  # <-- перемещаем кнопку "next" вниз        self.next_end_button.draw(self.screen)  # <-- отрисовка кнопки "next"    # Отрисовывает экран завершения уровня    def draw_level_complete(self):        if self.level_before_start and len(self.completed_levels) < len(self.level_complete_images):            self.level_complete_image = self.level_complete_images[self.selected_level]            self.screen.blit(self.level_complete_image, (0, 0))            self.next_level_button.draw(self.screen)    # Отрисовывает экран инструкции перед уровнем    def draw_level_instruction_screen(self):        self.screen.fill(WHITE)        # Добавляем текст с целью уровня        text_font = load_font("assets/font/your_font.ttf", 30)        text_surface = text_font.render("Collect all items in 5 seconds!", True, BLACK)        text_rect = text_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2))        self.screen.blit(text_surface, text_rect)    # Отрисовывает игровой процесс    def draw_game(self):        level = self.levels[self.selected_level]        level.draw_background(self.screen)        if self.player:            self.player.update()            self.screen.blit(self.player.image, self.player.rect)        level.bonuses.draw(self.screen)        # Полупрозрачный фон для таймера и счета        timer_bg_surface = pygame.Surface((200, 60), pygame.SRCALPHA)        timer_bg_surface.fill((255, 255, 255, 128))        self.screen.blit(timer_bg_surface, (5, 5))        # Таймер игры        self.game_time = (pygame.time.get_ticks() - self.start_time) / 1000        time_text = self.font.render(f"Time: {self.game_time:.2f} s", True,                                     BLACK)        self.screen.blit(time_text, (10, 10))        score_text = self.font.render(f"Score: {self.score}", True, BLACK)        self.screen.blit(score_text, (10, 40))        # Проверка столкновений и начисление очков        if self.player:            collected_bonuses = pygame.sprite.spritecollide(self.player,                                                            level.bonuses, True)            self.score += len(collected_bonuses)        # Проверка времени уровня и перезапуск, если время вышло и не все бонусы        # собраны        if self.game_time > level.level_time:            level.bonuses.empty()            if level.initial_bonus_positions:                for x, y, image_path in level.initial_bonus_positions:                    level.bonuses.add(Bonus(x, y, image_path))            self.start_game()        if self.player and self.player.rect.x > WIDTH - 100:            if not self.end_game_button:                if len(self.completed_levels) == 2:                    self.end_game_button = Button("Next level", WIDTH // 2,                                                  HEIGHT // 2 + 100, 150, 40,                                                  action="end_menu_select")                else:                    self.end_game_button = Button("Next level", WIDTH // 2,                                                  HEIGHT // 2 + 100, 150, 40,                                                  action="start_menu")            self.end_game_button.draw(self.screen)    # Отрисовывает финальный экран    def draw_final_screen(self):        self.screen.blit(self.final_screen_image, (0, 0))        self.final_quit_button.draw(self.screen)        self.final_restart_button.draw(self.screen)    # Запускает игру на текущем уровне    def start_game(self):        level = self.levels[self.selected_level]        self.player = Player(self.selected_character, level.start_x,                             level.start_y)        self.start_time = pygame.time.get_ticks()        self.game_time = 0    # Сбрасывает состояние игры к начальному    def reset_game(self):        self.completed_levels = set()        self.selected_character = None        self.selected_level = None        self.score = 0        self.player = None        self.character_changed = False        for button in self.character_buttons:            button.unselect()DB_PATH = os.path.join('db', 'scores.db')if __name__ == "__main__":    game = SceneManager(DB_PATH)    game.run()
from flask import Blueprint, render_template, request, jsonify, send_filefrom forms import (LoginForm, TeacherRegistrationForm, AddAvailabilityForm, AddTeacherForm, AddDateForm, AddSubjectForm,                   DeleteDateForm, DeleteSubjectForm, DeleteTeacherForm)from flask_login import login_user, login_required, logout_user, current_userfrom models import User, Date, Subject, Availability, Appointmentfrom werkzeug.security import generate_password_hash, check_password_hashfrom sqlalchemy import and_import iofrom extensions import dbimport subprocessfrom datetime import datetime, time, timedeltafrom flask import flash, redirect, url_for# Создаем Blueprint для маршрутовroutes_bp = Blueprint('routes', __name__)# Главная страница@routes_bp.route('/')def index():    if current_user.is_authenticated:        return redirect(            url_for('routes.teacher_dashboard'))    return render_template('index.html')# Страница входа для учителя@routes_bp.route('/teacher_login', methods=['GET', 'POST'])def teacher_login():    form = LoginForm()    if form.validate_on_submit():        user = User.query.filter_by(username=form.username.data).first()        if user and check_password_hash(user.password, form.password.data):            login_user(user)            flash('Вы успешно зашли в свой аккаунт!', 'success_login')            return redirect(url_for('routes.index'))        else:            flash('Неправильное имя пользователя или пароль', 'error')    return render_template('teacher_login.html', form=form)# Страница регистрации учителя@routes_bp.route('/teacher_register', methods=['GET', 'POST'])def teacher_register():    form = TeacherRegistrationForm()    if form.validate_on_submit():        admin_password = request.form.get('admin_password')        admin = User.query.filter_by(is_admin=True).first()        if admin and check_password_hash(admin.password, admin_password):            existing_user = User.query.filter_by(username=form.username.data).first()            if existing_user:                flash('Имя пользователя уже занято. Пожалуйста, выберите другое.', 'error')                return render_template('teacher_register.html', form=form)            hashed_password = generate_password_hash(form.password.data, method='pbkdf2:sha256')            new_teacher = User(username=form.username.data, password=hashed_password)            db.session.add(new_teacher)            db.session.commit()            flash('Регистрация прошла успешно! Теперь вы можете войти.', 'success')            return redirect(url_for('routes.teacher_login'))        else:            flash('Неверный пароль администратора.', 'error')    return render_template('teacher_register.html', form=form)# Панель управления учителя (требуется вход)@routes_bp.route('/teacher_dashboard')@login_requireddef teacher_dashboard():    return render_template('teacher_dashboard.html', user=current_user)# Выход из системы (требуется вход)@routes_bp.route('/logout')@login_requireddef logout():    logout_user()    flash('Вы вышли из системы.', 'info')  # Сообщение об успешном выходе    return redirect(url_for('routes.index'))# Страница управления доступностью учителя (требуется вход)@routes_bp.route('/teacher_availability', methods=['GET', 'POST'])@login_requireddef teacher_availability():    add_availability_form = AddAvailabilityForm()    delete_date_form = DeleteDateForm()    delete_subject_form = DeleteSubjectForm()    delete_teacher_form = DeleteTeacherForm()    add_availability_form.date.choices = [(d.id, d.date) for d in Date.query.all()]    add_availability_form.subject.choices = [(s.id, s.name) for s in Subject.query.all()]    add_availability_form.teacher.choices = [(t.id, t.username) for t in User.query.filter_by(is_admin=False).all()]    delete_date_form.date_id.choices = [(d.id, d.date) for d in Date.query.all()]    delete_subject_form.subject_id.choices = [(s.id, s.name) for s in Subject.query.all()]    delete_teacher_form.teacher_id.choices = [(t.id, t.username) for t in User.query.filter_by(is_admin=False).all()]    if request.method == 'POST':        if add_availability_form.validate_on_submit() and add_availability_form.submit.data:            date_id = add_availability_form.date.data            subject_id = add_availability_form.subject.data            teacher_id = add_availability_form.teacher.data            start_time = add_availability_form.start_time.data            end_time = add_availability_form.end_time.data            duration = add_availability_form.duration.data            existing_availability = Availability.query.filter_by(                date_id=date_id,                subject_id=subject_id,                teacher_id=teacher_id,                start_time=start_time,                end_time=end_time            ).first()            if existing_availability:                flash('Такая доступность уже существует.', 'error')            else:                new_availability = Availability(                    date_id=date_id,                    subject_id=subject_id,                    teacher_id=teacher_id,                    start_time=start_time,                    end_time=end_time,                    duration=duration                )                db.session.add(new_availability)                db.session.commit()                flash('Консультации успешно добавлены!', 'success')            return redirect(url_for('routes.teacher_availability'))        if delete_date_form.validate_on_submit() and delete_date_form.submit.data:            date_to_delete = Date.query.get(delete_date_form.date_id.data)            if date_to_delete:                db.session.delete(date_to_delete)                db.session.commit()                flash('Дата успешно удалена!', 'success')            else:                flash('Дата не найдена.', 'error')            return redirect(url_for('routes.teacher_availability'))        if delete_subject_form.validate_on_submit() and delete_subject_form.submit.data:            subject_to_delete = Subject.query.get(delete_subject_form.subject_id.data)            if subject_to_delete:                Availability.query.filter_by(subject_id=subject_to_delete.id).delete()                db.session.delete(subject_to_delete)                db.session.commit()                flash('Предмет успешно удален!', 'success')            else:                flash('Предмет не найден.', 'error')            return redirect(url_for('routes.teacher_availability'))        if delete_teacher_form.validate_on_submit() and delete_teacher_form.submit.data:            teacher_to_delete = User.query.get(delete_teacher_form.teacher_id.data)            if teacher_to_delete:                db.session.delete(teacher_to_delete)                db.session.commit()                flash('Учитель успешно удален!', 'success')            else:                flash('Учитель не найден.', 'error')            return redirect(url_for('routes.teacher_availability'))    availabilities = Availability.query.all()    return render_template('teacher_availability.html',                           add_availability_form=add_availability_form,                           delete_date_form=delete_date_form,                           delete_subject_form=delete_subject_form,                           delete_teacher_form=delete_teacher_form,                           availabilities=availabilities)# Страница добавления учителя (требуется вход)@routes_bp.route('/add_teacher', methods=['GET', 'POST'])@login_requireddef add_teacher_route():    form = AddTeacherForm()    if form.validate_on_submit():        existing_user = User.query.filter_by(username=form.teacher.data).first()        if existing_user:            flash('Имя пользователя уже занято. Пожалуйста, выберите другое.', 'error')            return render_template('add_teacher.html', form=form)        new_teacher = User(            username=form.teacher.data,            password=generate_password_hash('default_password', method='pbkdf2:sha256')        )        db.session.add(new_teacher)        db.session.commit()        flash('Учитель успешно добавлен!', 'success')        return redirect(url_for('routes.add_teacher_route'))    return render_template('add_teacher.html', form=form)# Страница добавления даты (требуется вход)@routes_bp.route('/add_date', methods=['GET', 'POST'])@login_requireddef add_date_route():    form = AddDateForm()    if form.validate_on_submit():        try:            date_value = datetime.strptime(form.date.data, '%Y-%m-%d').date()            new_date = Date(date=date_value)            db.session.add(new_date)            db.session.commit()            flash('Дата успешно добавлена!', 'success')            return render_template('add_date.html', form=form)        except Exception as e:            db.session.rollback()            flash(f'Ошибка при добавлении даты: {str(e)}', 'error')    return render_template('add_date.html', form=form)# Страница добавления предмета (требуется вход)@routes_bp.route('/add_subject', methods=['GET', 'POST'])@login_requireddef add_subject_route():    form = AddSubjectForm()    if form.validate_on_submit():        subject_name = form.subject.data        existing_subject = Subject.query.filter_by(name=subject_name).first()        if existing_subject:            flash(f'Предмет с названием "{subject_name}" уже существует. Пожалуйста, введите другое название.', 'error')            return render_template('add_subject.html', form=form)        # Если предмет не существует, добавляем его        new_subject = Subject(name=subject_name)        db.session.add(new_subject)        db.session.commit()        flash('Предмет успешно добавлен!', 'success')        return render_template('add_subject.html', form=form)    return render_template('add_subject.html', form=form)# Страница бронирования консультации@routes_bp.route('/booking')def booking():    dates = Date.query.all()    subjects = Subject.query.all()    teachers = User.query.filter_by(is_admin=False).all()    return render_template('booking.html', dates=dates, subjects=subjects, teachers=teachers)# Обработка бронирования консультации@routes_bp.route('/book', methods=['POST'])def book():    date_id = request.form['date']    subject_id = request.form['subject']    teacher_id = request.form['teacher']    start_time_str = request.form['time']    fio = request.form['fio']    if start_time_str:        start_time = datetime.strptime(start_time_str, '%H:%M').time()        print(            f"book: date_id={date_id}, subject_id={subject_id}, "            f"teacher_id={teacher_id}, start_time_str={start_time_str}, "            f"start_time={start_time}"        )        availability = Availability.query.filter(            Availability.date_id == date_id,            Availability.subject_id == subject_id,            Availability.teacher_id == teacher_id,            Availability.start_time <= start_time,            Availability.end_time >= start_time        ).first()        if availability:            appointment = Appointment(availability_id=availability.id, fio=fio)            db.session.add(appointment)            db.session.commit()            flash('Вы успешно записались на консультацию!', 'success_appointment')            buffer = io.BytesIO()            # Получаем данные для TXT            date = Date.query.get(date_id)            subject = Subject.query.get(subject_id)            teacher = User.query.get(teacher_id)            # Формируем текст для TXT            text = [                f"ФИО родителя: {fio}",                f"Дата: {date.date}",                f"Предмет: {subject.name}",                f"Учитель: {teacher.username}",                f"Время: {start_time.strftime('%H:%M')}"            ]            # Добавляем текст в TXT            for line in text:                buffer.write((line + '\n').encode('utf-8'))  # Кодируем в байты            buffer.seek(0)            # Отправляем TXT-файл пользователю            return send_file(                buffer,                mimetype='text/plain',                as_attachment=True,                download_name='consultation_details.txt'            )        else:            flash('Не найдено доступное время с указанными параметрами.', 'error')            return redirect(url_for('routes.booking'))    else:        flash('Пожалуйста, выберите время.', 'error')        return redirect(url_for('routes.booking'))# Получение доступного времени для бронирования@routes_bp.route('/get_available_times')def get_available_times():    date_id = request.args.get('date_id')    subject_id = request.args.get('subject_id')    teacher_id = request.args.get('teacher_id')    selected_date = Date.query.get(date_id)    if not selected_date:        return jsonify([])    # Находим все доступности для выбранной даты, предмета и учителя    availabilities = Availability.query.filter_by(        date_id=date_id,        subject_id=subject_id,        teacher_id=teacher_id    ).all()    available_slots = []    for availability in availabilities:        start_time = availability.start_time        end_time = availability.end_time        time_interval = timedelta(minutes=30)        # Преобразуем start_time и end_time в объекты datetime для сравнения        current_time = datetime.combine(datetime.today(), start_time)        end_datetime = datetime.combine(datetime.today(), end_time)        # Генерируем временные слоты с заданным интервалом        while current_time + time_interval <= end_datetime:            slot_start_time = current_time.time()            slot_end_time = (current_time + time_interval).time()            # Проверяем, нет ли уже записи на это время            is_booked = Appointment.query.join(Availability).filter(                and_(                    Availability.date_id == date_id,                    Availability.subject_id == subject_id,                    Availability.teacher_id == teacher_id,                    Availability.start_time == slot_start_time                )            ).first()            if not is_booked:                # Если слот не забронирован, добавляем его в список                available_slots.append(slot_start_time.strftime('%H:%M'))            # Переходим к следующему временному слоту            current_time += time_interval    return jsonify(available_slots)@routes_bp.route('/parent')def parent_route():    return redirect(url_for('routes.booking'))# Список всех записей на консультации (требуется вход)@routes_bp.route('/appointments')@login_requireddef appointments():    appointments = Appointment.query.all()    return render_template('appointments.html', appointments=appointments)# Генерация временных слотовdef generate_time_slots(start_time=time(9, 0), end_time=time(17, 0), interval=timedelta(minutes=30)):    times = []    current_time = datetime.combine(datetime.today(), start_time)    end_datetime = datetime.combine(datetime.today(), end_time)    while current_time <= end_datetime:        times.append(current_time.time())        current_time += interval    return times